/* src/app_pages/process_page/ProcessPage.svelte generated by Svelte v3.31.1 */
import {
	SvelteComponent,
	append,
	destroy_block,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	update_keyed_each
} from "../../../web_modules/svelte/internal.js";

import { fetchFile } from "../../../web_modules/@ffmpeg/ffmpeg.js";
import { AppStateStore } from "../../app_state/app-state.js";
import { VideoFile } from "../../files/file.js";
import { onMount } from "../../../web_modules/svelte.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (43:2) {#each uploadedFiles as video (video.id)}
function create_each_block_1(key_1, ctx) {
	let li;
	let t_value = /*video*/ ctx[7].fileName + "";
	let t;

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			t = text(t_value);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*uploadedFiles*/ 1 && t_value !== (t_value = /*video*/ ctx[7].fileName + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

// (52:2) {#each outputFiles as video (video.id)}
function create_each_block(key_1, ctx) {
	let li;
	let t_value = /*video*/ ctx[7].fileName + "";
	let t;

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			t = text(t_value);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*outputFiles*/ 2 && t_value !== (t_value = /*video*/ ctx[7].fileName + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(li);
		}
	};
}

function create_fragment(ctx) {
	let h20;
	let t1;
	let ol0;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t2;
	let h1;
	let t3;
	let t4;
	let t5;
	let h21;
	let t7;
	let ol1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let each_value_1 = /*uploadedFiles*/ ctx[0];
	const get_key = ctx => /*video*/ ctx[7].id;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = /*outputFiles*/ ctx[1];
	const get_key_1 = ctx => /*video*/ ctx[7].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			h20 = element("h2");
			h20.textContent = "QUEUE";
			t1 = space();
			ol0 = element("ol");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = space();
			h1 = element("h1");
			t3 = text("CURRENT JOB PROGRESS: ");
			t4 = text(/*progress*/ ctx[2]);
			t5 = space();
			h21 = element("h2");
			h21.textContent = "FINISHED";
			t7 = space();
			ol1 = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
		},
		m(target, anchor) {
			insert(target, h20, anchor);
			insert(target, t1, anchor);
			insert(target, ol0, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(ol0, null);
			}

			insert(target, t2, anchor);
			insert(target, h1, anchor);
			append(h1, t3);
			append(h1, t4);
			insert(target, t5, anchor);
			insert(target, h21, anchor);
			insert(target, t7, anchor);
			insert(target, ol1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol1, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*uploadedFiles*/ 1) {
				each_value_1 = /*uploadedFiles*/ ctx[0];
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, ol0, destroy_block, create_each_block_1, null, get_each_context_1);
			}

			if (dirty & /*progress*/ 4) set_data(t4, /*progress*/ ctx[2]);

			if (dirty & /*outputFiles*/ 2) {
				each_value = /*outputFiles*/ ctx[1];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, ol1, destroy_block, create_each_block, null, get_each_context);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h20);
			if (detaching) detach(t1);
			if (detaching) detach(ol0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(h1);
			if (detaching) detach(t5);
			if (detaching) detach(h21);
			if (detaching) detach(t7);
			if (detaching) detach(ol1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let progress;
	
	let { uploadedFiles } = $$props;
	let { ffmpeg } = $$props;
	let { outputFormat } = $$props;
	console.log(uploadedFiles);
	let outputFiles = [];
	let progressRatio = 0;

	const processUploadedFiles = async () => {
		// Hook into the ffmpeg command progress
		ffmpeg.setProgress(({ ratio }) => {
			$$invalidate(5, progressRatio = ratio);
		});

		for (let index = 0; index < uploadedFiles.length; index++) {
			const video = uploadedFiles[index];

			// Add the video file to the ffmpeg file system.
			ffmpeg.FS("writeFile", video.fileName, await fetchFile(video.fileURL));

			// Convert video file.
			await ffmpeg.run("-i", video.fileName, `${video.id}.${outputFormat}`);

			// Retrive the output file.
			const data = ffmpeg.FS("readFile", `${video.id}.${outputFormat}`);

			const outputFile = new File([new Blob([data.buffer])], `${video.basename}.${outputFormat}`, { type: `video/${outputFormat}` });
			$$invalidate(1, outputFiles = [...outputFiles, new VideoFile(outputFile)]);
		}

		// TODO: Probably need to do some cleanup here.
		AppStateStore.setOutputFiles(outputFiles);

		AppStateStore.incrementState();
	};

	// Start Processing files when the component has mounted.
	onMount(() => {
		processUploadedFiles();
	});

	$$self.$$set = $$props => {
		if ("uploadedFiles" in $$props) $$invalidate(0, uploadedFiles = $$props.uploadedFiles);
		if ("ffmpeg" in $$props) $$invalidate(3, ffmpeg = $$props.ffmpeg);
		if ("outputFormat" in $$props) $$invalidate(4, outputFormat = $$props.outputFormat);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*progressRatio*/ 32) {
			$: $$invalidate(2, progress = 100 * progressRatio);
		}
	};

	return [uploadedFiles, outputFiles, progress, ffmpeg, outputFormat, progressRatio];
}

class ProcessPage extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			uploadedFiles: 0,
			ffmpeg: 3,
			outputFormat: 4
		});
	}
}

export default ProcessPage;